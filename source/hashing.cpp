#include "stdafx.h"
#include "hashing.h"
#include "Utils.h"

static bool CanBeHash(char* msg, int msgSize)
{
	for (int i = 0; i < msgSize; i++)
	{
		if (!isalnum(msg[i]))
			return false;
	}
	return true;
}

std::string HashList::GetFileHash( const wchar_t* FileName ) const
{
	StringMap::const_iterator it = m_HashList.find(FileName);
	if (it != m_HashList.end())
		return (*it).second;
	
	return "";
}

void HashList::SetFileHash( const wchar_t* FileName, std::string HashVal )
{
	m_HashList[FileName] = HashVal;
}

bool HashList::SaveList( const wchar_t* filepath )
{
	stringstream sstr;
	char szFilenameBuf[MAX_PATH];

	sstr << "; Generated by Integrity Checker Plugin (by Ariman)" << endl;

	StringMap::const_iterator cit;
	for (cit = m_HashList.begin(); cit != m_HashList.end(); cit++)
	{
		WideCharToMultiByte(m_Codepage, 0, cit->first.c_str(), -1, szFilenameBuf, ARRAY_SIZE(szFilenameBuf), NULL, NULL);
		if (m_HashId == RHASH_CRC32)
			sstr << szFilenameBuf << " " << cit->second << endl;
		else
			sstr << cit->second << " *" << szFilenameBuf << endl;
	}

	HANDLE hFile = CreateFile(filepath, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (hFile == INVALID_HANDLE_VALUE) return false;

	string strData = sstr.str();
	DWORD numWritten;
	
	bool retVal = WriteFile(hFile, strData.c_str(), strData.length(), &numWritten, NULL) && (numWritten == strData.length());
	
	CloseHandle(hFile);
	return retVal;
}

int HashList::LoadList( const wchar_t* filepath, bool replaceExisting /*= true*/ )
{
	//TODO: implement
	return 0;
}

bool HashList::SaveListSeparate( const wchar_t* baseDir )
{
	//TODO: implement
	return false;
}

//////////////////////////////////////////////////////////////////////////

int GenerateHash( const wchar_t* filePath, rhash_ids hashAlgo, char* result, HashingProgressFunc progressFunc, HANDLE progressContext )
{
	HANDLE hFile = CreateFile(filePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);
	if (hFile == INVALID_HANDLE_VALUE) return GENERATE_ERROR;

	const size_t readBufSize = 32 * 1024;
	char readBuf[32 * 1024];
	DWORD numReadBytes;

	int retVal = GENERATE_SUCCESS;
	int64_t totalBytes = GetFileSize_i64(hFile);

	rhash hashCtx = rhash_init(hashAlgo);
	while (retVal == GENERATE_SUCCESS && totalBytes > 0)
	{
		if (!ReadFile(hFile, readBuf, readBufSize, &numReadBytes, NULL) || !numReadBytes)
		{
			retVal = GENERATE_ERROR;
			break;
		}

		totalBytes -= numReadBytes;
		rhash_update(hashCtx, readBuf, numReadBytes);

		if (progressFunc != NULL)
		{
			if (!progressFunc(progressContext, numReadBytes))
				retVal = GENERATE_ABORTED;
		}
	}
	
	if (retVal == GENERATE_SUCCESS)
	{
		rhash_final(hashCtx, NULL);
		rhash_print(result, hashCtx, hashAlgo, RHPR_HEX);
	}

	rhash_free(hashCtx);
	CloseHandle(hFile);
	return retVal;
}

static wstring GetFullPath(const wchar_t* path)
{
	wchar_t tmpBuf[4096];
	GetFullPathName(path, ARRAY_SIZE(tmpBuf), tmpBuf, NULL);
	return tmpBuf;
}

static int EnumFiles(const wstring& baseAbsPath, const wstring& pathPrefix, StringList &destList, bool recursive)
{
	wstring strBasePath = baseAbsPath + L"*.*";

	WIN32_FIND_DATA fd;
	HANDLE hFind;
	int numFound = 0;

	hFind = FindFirstFile(strBasePath.c_str(), &fd);
	if (hFind == INVALID_HANDLE_VALUE) return 0;

	do 
	{
		if (wcscmp(fd.cFileName, L".") == 0 || wcscmp(fd.cFileName, L"..") == 0)
			continue;

		if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0 && recursive)
		{
			wstring strNexBasePath = baseAbsPath + fd.cFileName;
			strNexBasePath += L"\\";
			wstring strNextPrefix = pathPrefix + fd.cFileName;
			strNextPrefix += L"\\";
			
			numFound += EnumFiles(strNexBasePath, strNextPrefix, destList, recursive);
		}
		else
		{
			destList.push_back(pathPrefix + fd.cFileName);
			numFound++;
		}
	} while (FindNextFile(hFind, &fd));
	
	FindClose(hFind);
	return numFound;
}

int PrepareFilesList(const wchar_t* basePath, const wchar_t* basePrefix, StringList &destList, bool recursive)
{
	wstring strBasePath = GetFullPath(basePath);
	wstring strStartPrefix(basePrefix);
	
	IncludeTrailingPathDelim(strBasePath);
	IncludeTrailingPathDelim(strStartPrefix);
	
	return EnumFiles(strBasePath, strStartPrefix, destList, recursive);
}
