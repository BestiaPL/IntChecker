#include "stdafx.h"
#include "hashing.h"
#include "Utils.h"

HashAlgoInfo SupportedHashes[] = {
	{RHASH_CRC32, 8, false, 1, L".sfv", L"CRC32"},
	{RHASH_MD5, 32, true, 2, L".md5", L"MD5"},
	{RHASH_SHA1, 40, true, 2, L".sha1", L"SHA1"},
	{RHASH_SHA256, 64, true, 2, L".sha256", L"SHA-256"},
	{RHASH_SHA512, 128, true, 2, L".sha512", L"SHA-512"},
	{RHASH_WHIRLPOOL, 128, true, 2, L".wrpl", L"Whirlpool"}
};

static bool CanBeHash(const char* msg, int msgSize)
{
	for (int i = 0; i < msgSize; i++)
	{
		if (msg[i] <= 31 || !isxdigit(msg[i]))
			return false;
	}
	return true;
}

static bool CanBePath(const char* msg, int msgSize)
{
	const char* IllegalPathChars = "<>\"|?*";
	for (int i = 0; i < msgSize; i++)
	{
		if (!msg[i]) break;
		if ((msg[i] <= 31) || (strchr(IllegalPathChars, msg[i]) != NULL))
			return false;
	}
	return true;
}

static bool CanBePath(const wchar_t* str)
{
	const wchar_t* IllegalPathChars = L"<>\"|?*";

	size_t strLen = wcslen(str);
	for (size_t i = 0; i < strLen; i++)
	{
		if ((str[i] <= 31) || (wcschr(IllegalPathChars, str[i]) != NULL))
			return false;
	}
	return true;
}

static bool IsComment(char* line)
{
	char* strPtr = line;
	while (strPtr && *strPtr)
	{
		// Comments start with semicolon
		if (*strPtr == ';')
			return true;
		
		// Spaces are allowed before semicolon
		if (!isspace(*strPtr) && *strPtr != '\t')
			return false;

		strPtr++;
	}
	return true;
}

static bool IsDelimChar(char c)
{
	return isspace(c) || (c == '*');
}

HashAlgoInfo* GetAlgoInfo(rhash_ids algoId)
{
	int i = GetAlgoIndex(algoId);
	return i >= 0 ? &SupportedHashes[i] : nullptr;
}

int GetAlgoIndex(rhash_ids algoId)
{
	for (int i = 0; i < NUMBER_OF_SUPPORTED_HASHES; i++)
	{
		if (SupportedHashes[i].AlgoId == algoId)
			return i;
	}
	return -1;
}

//////////////////////////////////////////////////////////////////////////

std::string HashList::GetFileHash( const wchar_t* FileName ) const
{
	int index = GetFileRecordIndex(FileName);
	return (index >= 0) ? m_HashList[index].HashStr : "";
}

void HashList::SetFileHash( const wchar_t* FileName, std::string HashVal )
{
	int index = GetFileRecordIndex(FileName);
	if (index >= 0)
	{
		m_HashList[index].HashStr = HashVal;
	}
	else
	{
		FileHashInfo info;
		info.Filename = FileName;
		info.HashStr = HashVal;

		m_HashList.push_back(info);
	}
}

bool HashList::SaveList( const wchar_t* filepath )
{
	stringstream sstr;

	sstr << "; Generated by Integrity Checker Plugin (by Ariman)" << endl << endl;
	for (vector<FileHashInfo>::const_iterator cit = m_HashList.begin(); cit != m_HashList.end(); cit++)
	{
		const FileHashInfo& hashData = *cit;
		SerializeFileHash(hashData, sstr);
		sstr << endl;
	}

	string strData = sstr.str();
	return DumpStringToFile(strData.c_str(), strData.length(), filepath);
}

bool HashList::SaveListSeparate( const wchar_t* baseDir )
{
	wstring dirName(baseDir);
	IncludeTrailingPathDelim(dirName);

	HashAlgoInfo* algoInfo = GetAlgoInfo(m_HashId);
	if (algoInfo == NULL) return false;

	for (vector<FileHashInfo>::const_iterator cit = m_HashList.begin(); cit != m_HashList.end(); cit++)
	{
		const FileHashInfo& hashData = *cit;
		wstring destFilePath = dirName + hashData.Filename + algoInfo->DefaultExt;
		
		stringstream sstr;
		sstr << "; Generated by Integrity Checker Plugin (by Ariman)" << endl << endl;
		SerializeFileHash(hashData, sstr);
		sstr << endl;

		string strData = sstr.str();
		if (!DumpStringToFile(strData.c_str(), strData.length(), destFilePath.c_str()))
			return false;
	}
	
	return true;
}

bool HashList::LoadList( const wchar_t* filepath )
{
	char readBuf[1024];
	FILE* inputFile;

	m_HashList.clear();

	// Do not accept files larger then 10Mb
	int64_t fileSize = GetFileSize_i64(filepath);
	if ((fileSize <= 0) || (fileSize > 10 * 1024 * 1024)) return false;
	
	if (_wfopen_s(&inputFile, filepath, L"r") != 0)
		return false;

	bool fres = true;
	int listAlgoIndex = -1;
	HashListFormat listFormat = HLF_UNKNOWN;
	vector<FileHashInfo> parsedList;

	while (fgets(readBuf, sizeof(readBuf), inputFile))
	{
		TrimRight(readBuf);

		// Just skipping comment lines
		if (IsComment(readBuf)) continue;
		
		if (listAlgoIndex < 0)
		{
			if (!DetectHashAlgo(readBuf, filepath, listAlgoIndex, listFormat))
			{
				fres = false;
				break;
			}
			m_HashId = SupportedHashes[listAlgoIndex].AlgoId;
		}

		FileHashInfo fileInfo;
		if (ParseLine(readBuf, listAlgoIndex, fileInfo))
		{
			parsedList.push_back(fileInfo);
		}
	}
	fclose(inputFile);

	if (fres)
	{
		m_HashList.insert(m_HashList.end(), parsedList.begin(), parsedList.end());
	}

	return fres;
}

int HashList::GetFileRecordIndex( const wchar_t* fileName ) const
{
	for (size_t i = 0; i < m_HashList.size(); i++)
	{
		const FileHashInfo& info = m_HashList[i];
		if (wcscmp(info.Filename.c_str(), fileName) == 0)
			return (int) i;
	}

	return -1;
}

bool HashList::DumpStringToFile( const char* data, size_t dataSize, const wchar_t* filePath )
{
	HANDLE hFile = CreateFile(filePath, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (hFile == INVALID_HANDLE_VALUE) return false;

	DWORD numWritten;
	bool retVal = WriteFile(hFile, data, (DWORD) dataSize, &numWritten, NULL) && (numWritten == dataSize);
	CloseHandle(hFile);

	return retVal;
}

void HashList::SerializeFileHash( const FileHashInfo& data, stringstream& dest )
{
	char szFilenameBuf[PATH_BUFFER_SIZE] = {0};
	
	WideCharToMultiByte(m_Codepage, 0, data.Filename.c_str(), -1, szFilenameBuf, ARRAY_SIZE(szFilenameBuf), NULL, NULL);
	if (m_HashId == RHASH_CRC32)
		dest << szFilenameBuf << " " << data.HashStr;
	else
		dest << data.HashStr << " *" << szFilenameBuf;
}

bool HashList::ParseLine( const char* inputStr, int hashAlgoIndex, FileHashInfo &fileInfo )
{
	size_t strSize = strlen(inputStr);
	HashAlgoInfo* algo = &SupportedHashes[hashAlgoIndex];
	
	const char *possibleHash, *possiblePath, *delimStart;
	wchar_t wpathBuf[PATH_BUFFER_SIZE];
	
	// First check if line is too short
	if ((int)strSize < algo->HashStrSize + algo->NumDelimSpaces + 1)
	{
		return false;
	}

	if (algo->HashBeforePath)
	{
		possibleHash = inputStr;
		possiblePath = inputStr + (algo->HashStrSize + algo->NumDelimSpaces);
		delimStart = possibleHash + algo->HashStrSize;
	}
	else
	{
		possiblePath = inputStr;
		possibleHash = inputStr + (strSize - algo->HashStrSize);
		delimStart = possibleHash - algo->NumDelimSpaces;
	}

	if (!CanBeHash(possibleHash, algo->HashStrSize))
	{
		return false;
	}

	for (int i = 0; i < algo->NumDelimSpaces; i++)
	{
		if (!IsDelimChar(delimStart[i]))
			return false;
	}

	int possiblePathSize = (int) (strSize - algo->HashStrSize - algo->NumDelimSpaces);
	int numChars = MultiByteToWideChar(m_Codepage, 0, possiblePath, possiblePathSize, wpathBuf, ARRAY_SIZE(wpathBuf));
	wpathBuf[numChars] = '\0';

	if (CanBePath(wpathBuf))	
	{
		fileInfo.Filename = wpathBuf;
		fileInfo.HashStr.assign(possibleHash, algo->HashStrSize);

		return true;
	}

	return false;
}

bool HashList::DetectHashAlgo( const char* testStr, const wchar_t* filePath, int &foundAlgoIndex, HashListFormat &listFormat )
{
	FileHashInfo fileInfo;
	int foundAlgo = -1;

	// Some hashes have same length of hash string
	// In this case we will distinguish algorithm by file extension

	wstring path(filePath);
	wstring ext = ExtractFileExt(path);

	for (int i = 0; i < NUMBER_OF_SUPPORTED_HASHES; i++)
	{
		if (ParseLine(testStr, i, fileInfo))
		{
			bool sameExt = (_wcsicmp(ext.c_str(), SupportedHashes[i].DefaultExt.c_str()) == 0);
			if ((foundAlgo < 0) || sameExt)
			{
				foundAlgo = i;
			}
			if (sameExt) break;
		}
	}

	if (foundAlgo >= 0)
	{
		foundAlgoIndex = foundAlgo;
		listFormat = HLF_SIMPLE;
		return true;
	}
	
	return false;
}

std::wstring HashList::FileInfoToString( size_t index )
{
	if (index < 0 || index >= m_HashList.size())
		return L"";

	FileHashInfo& fileInfo = m_HashList[index];

	wchar_t hashStrBuf[PATH_BUFFER_SIZE] = {0};
	MultiByteToWideChar(m_Codepage, 0, fileInfo.HashStr.c_str(), (int) fileInfo.HashStr.size(), hashStrBuf, ARRAY_SIZE(hashStrBuf));
	
	wstringstream wsstr;
	if (m_HashId == RHASH_CRC32)
		wsstr << fileInfo.Filename << " " << hashStrBuf;
	else
		wsstr << hashStrBuf << " *" << fileInfo.Filename;

	return wsstr.str();
}

//////////////////////////////////////////////////////////////////////////

int GenerateHash( const wchar_t* filePath, rhash_ids hashAlgo, char* result, HashingProgressFunc progressFunc, HANDLE progressContext )
{
	wstring strUniPath(PATH_EXTRALONG_PREFIX);
	strUniPath.append(filePath);
	
	HANDLE hFile = CreateFile(strUniPath.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);
	if (hFile == INVALID_HANDLE_VALUE) return GENERATE_ERROR;

	const size_t readBufSize = 32 * 1024;
	char readBuf[32 * 1024];
	DWORD numReadBytes;

	int retVal = GENERATE_SUCCESS;
	int64_t totalBytes = GetFileSize_i64(hFile);

	rhash hashCtx = rhash_init(hashAlgo);
	while (retVal == GENERATE_SUCCESS && totalBytes > 0)
	{
		if (!ReadFile(hFile, readBuf, readBufSize, &numReadBytes, NULL) || !numReadBytes)
		{
			retVal = GENERATE_ERROR;
			break;
		}

		totalBytes -= numReadBytes;
		rhash_update(hashCtx, readBuf, numReadBytes);

		if (progressFunc != NULL)
		{
			if (!progressFunc(progressContext, numReadBytes))
				retVal = GENERATE_ABORTED;
		}
	}
	
	if (retVal == GENERATE_SUCCESS)
	{
		rhash_final(hashCtx, NULL);
		rhash_print(result, hashCtx, hashAlgo, RHPR_HEX);
	}

	rhash_free(hashCtx);
	CloseHandle(hFile);
	return retVal;
}
